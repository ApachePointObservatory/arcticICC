I’ve been reading the API documentation and the low-level command documentation. My opinion is that the API is clumsy and doesn’t really do what we need. Fortunately it is just a thin wrapper around the low-level commands, so it is easy to do our own thing.

I propose we create a single C++ class that represents the camera and uses only the low-level calls (except *possibly* for startup and shutdown). The constructor should connect, initialize, set overscan and allocate the image buffer. The destructor undoes all that. This is the standard RAII pattern, and it is perfect for this sort of thing. We'll offer the obvious methods:
- Start exposure (specify exposure time and whether to open the shutter)
- Abort exposure
- Stop exposure (if we can figure out how to do it)
- Pause exposure
- Resume exposure
- Set bin factor
- Set subregion
- Set read rate
- Call Command to do low-level things from C++

Questions for Leach:
- Can one stop an exposure early and read it out?

Here are the direct commands needed (other than those for startup and shutdown):
SET: set exposure timer: issue this prior to sending SEX (used by Expose)
SEX: start an exposure (used by Expose)
PEX: pause exposure (closing shutter if need be)
REX: resume exposure (opening shutter if need be)
AEX: abort exposure without reading it out (used by Expose)
SSS: set subarray size (used by SetSubArray, which calls SSS first, then SSP)
    note that SSS, 0, 0, 0 resets to full frame (without calling SSP)!
SSP: set subarray position (used by SetSubArray)
WRM: set bin factor, and other things. To set bin factor:
    Command(TIM_ID, WRM, (Y_MEM | 0x5), binCols)
    Command(TIM_ID, WRM, (Y_MEM | 0x6), binRows)

By the way: the reason so many API commands take full image size as an argument is that the API always checks to see if the image buffer needs to be grown. That seems insane to me. As long as we specify the overscan at construction time we know that maximum image buffer size then and we never touch it.
