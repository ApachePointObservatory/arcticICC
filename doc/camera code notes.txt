I’ve been reading the API documentation and the low-level command documentation. My opinion is that the API is clumsy and doesn’t really do what we need. Fortunately it is just a thin wrapper around the low-level commands, so it is easy to do our own thing.

I propose we create a single C++ class that represents the camera and uses only the low-level calls (except *possibly* for startup and shutdown). The constructor should connect, initialize, set overscan and allocate the image buffer. The destructor undoes all that. This is the standard RAII pattern, and it is perfect for this sort of thing. We'll offer the obvious methods:
- Start exposure (specify exposure time and whether to open the shutter)
- Abort exposure
- Stop exposure and read out (how?)
- Pause exposure (how?)
- Resume exposure (how?)
- Get exposure state
- Get remaining exposure time
- Get and set bin factor
- Get and set subregion
- Get and set read rate
- Call Command to do low-level things from C++

Questions for Leach:
- Can I stop the exposure timer and read out the exposure?
- Can I pause an exposure (stop the timer and close the shutter, if it was open) and resume it later?

Here are some useful direct commands:
SET: set exposure timer: issue this prior to sending SEX (used by Expose)
SEX: start an exposure (used by Expose)
PEX: pause exposure (closing shutter if need be)
REX: resume exposure (opening shutter if need be)
AEX: abort exposure without reading it out (used by Expose)
SSS: set subarray size (used by SetSubArray, which calls SSS first, then SSP)
    note that SSS, 0, 0, 0 resets to full frame (without calling SSP)!
SSP: set subarray position (used by SetSubArray)
WRM: set bin factor, and other things. To set bin factor:
    Command(TIM_ID, WRM, (Y_MEM | 0x5), binCols)
    Command(TIM_ID, WRM, (Y_MEM | 0x6), binRows)
OSH: open shutter
CSH: close shutter

By the way: the reason so many API commands take full image size as an argument is that the API always checks to see if the image buffer needs to be grown. That seems insane to me. As long as we specify the overscan at construction time we know that maximum image buffer size then and we never touch it.
